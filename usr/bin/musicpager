#!/usr/bin/python3
#
#  chartdisplay.py
#
#  Copyright 2024 Len Ovens <len@ovenwerks.net>
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#  MA 02110-1301, USA.
#
#

import dbus
import fcntl
import gi
import io
import subprocess
import os
import json
import re
import rtmidi
import shlex
import shutil
import sys
import tempfile
import time
from os.path import expanduser
from rtmidi.midiutil import open_midiinput
from rtmidi.midiconstants import (CHANNEL_PRESSURE, CONTROLLER_CHANGE, NOTE_ON,
                                  NOTE_OFF, PITCH_BEND, POLY_PRESSURE, PROGRAM_CHANGE)
from weasyprint import HTML

gi.require_version("Gtk", "3.0")
gi.require_version('WebKit2', '4.1')

from gi.repository import Gtk, Gdk, Pango, WebKit2, GLib

# any module might be in local in some cases
global install_path
install_path = os.path.abspath(f"{sys.path[0]}/..")
#sys.path.insert(1, f"{install_path}/lib/python3/dist-packages")
#import my_lib


class ChordPro():

    def keyguess(self, chText):
        if chText.find('[') == -1:
            print("MT string, not a song")
            return "unknown"
        # remove all lines before the first line with [
        ourtxt = chText.split('[', 1)[1]
        if ourtxt.find('{') != -1:
            ourtxt = ourtxt.split('{', 1)[0]
        else:
            ourtxt = ourtxt.split('\n\n', 1)[0]
        keypool = ['Ab', 'A', 'Bb', 'B', 'C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G']
        ourpool = ['0','0','0','0','0','0','0','0','0','0','0','0']
        found = ourpool.copy()
        stdpool = "M0m0mM070m0D"
        shift = 0
        sharp = False
        basscrds = []
        size = 1
        for raw in ourtxt.split('['):
            raw = raw.split(']', 1)[0]
            if not raw[0] in "ABCDEFG":
                print(f"{raw} not a chord")
                continue
            if "#" in raw:
                size = 2
                sharp = True # key can only be ABDEGF#
            nn = ChordPro.note2num(self, raw[0:size])
            if len(raw.split('/', 1)) == 2:
                raw, bass = raw.split('/',1)
                bas = ChordPro.note2num(self, raw[0:size])
                if not bas in basscrds:
                    basscrds.append(bas)
            # remove maj7
            raw = raw.split('ma', 1)[0]
            if 'm' in raw:
                #minor
                raw = raw.split('m', 1)[0]
                ourpool[nn] = 'm'
            elif '7' in raw:
                raw = raw.split('7', 1)[0]
                ourpool[nn] = '7'
            elif 'dim' in raw:
                ourpool[nn] = 'D'
            else:
                if ourpool[nn] != '7':
                    ourpool[nn] = 'M'
        for b in basscrds:
            if ourpool[b] == '0':
                ourpool[b] = 'M'
            size = 1
        for x in range(0, 12):
            l1 = ourpool[x:12]
            l2 = ourpool[0:x]
            testl = l1 + l2
            fnd = 0
            for y in range(0, 12):
                tst = testl[y]
                std = stdpool[y]
                if tst == std:
                    fnd = fnd + 1
                elif tst == 'M' and std == '7':
                    fnd = fnd + 1
                elif tst == 'M' and std == 'D':
                    fnd = fnd + 1
            found[x] = fnd
        high = [0, found[0]]
        for z in range(1, 12):
            if found[z] > high[1]:
                high[0] = z
                high[1] = found[z]
        guessed = keypool[high[0]]
        if guessed == "Gb" and sharp:
            guessed = "F#"
        print(f"Guessed key: {guessed}")
        return guessed

    def rowheight(self, R_type, z):
        '''returns the height in px of row type and font size
        considering user set zooms'''
        global config
        ourdb = config['webkit']
        std = 16
        fnt = std
        ft = float(std * z)
        gap = float(int(ft * .4))
        # gap .4 works for zoom 100, 200, 300
        if R_type == 'blank':
            fnt = float(int(ft))
            h = fnt
        elif R_type == 'songline':
            lyr = float(ourdb['lyrics']['size'])/100
            cho = float(ourdb['chords']['size'])/100
            fnt = float(int((lyr * ft) + (cho * ft)))
            h = float(int(fnt + (gap * 2)))
        else :
            l = float(ourdb[R_type]['size'])/100
            fnt = float(int(l * ft))
            h = float(int(fnt + gap))
        return h, fnt

    def getOffset(self, crd, offset, key):
        # check for | :|| words etc. Is it really a chord?
        if not crd[0] in {'A', 'B', 'C', 'D', 'E', 'F', 'G'}:
            return crd # not a chord
        if offset == '0':
            return crd
        sz = len(crd)
        mid = ""
        if sz > 1 and crd[1] in {'#', 'b'}:
            tcrd = crd[0:2]
            if sz > 2:
                mid = crd[2:]
        else:
            tcrd = crd[0]
            if sz > 1:
                mid = crd[1:]
        bn = ""
        bp = sz
        if '/' in mid:
            bp = mid.find('/')
            bn = mid[bp + 1:]
            mid = mid[0:bp +1]
        cd = ChordPro.shiftnote(self, tcrd, offset, key)
        bs = ""
        if len(bn):
            bs = ChordPro.shiftnote(self, bn, offset, key)
        return f"{cd}{mid}{bs}"

    def getlongline(self, instring):
        '''Take a chordpro document and find the longest line
            return the length in non-zoomed pixels (10px/char)
            lines that might be split like subtitle or copyright
            are not included.
        '''
        longest = 0
        buf = io.StringIO(instring)
        for line in buf:
            if line[0] == '{':
                continue
            if '{copy' in line or 'Â©' in line or '(c)' in line:
                break
            llen = 0
            ourline = line.strip()
            if ourline.find("[") == -1:
                if len(ourline) > llen:
                    llen = len(ourline)
                continue
            for sub in ourline.split('['):
                # each sub has either one ] or none
                if sub == "":
                    # line begins with [ so empty sub skip
                    continue
                pre, bra, tail = sub.partition("]")
                if bra == "" or tail == "":
                    #whole thing should be text, no chords
                    # or the chord is at the end of the line and
                    # should be counted
                    llen = llen + len(pre)
                else:
                    llen = llen + len(tail)
            if llen > longest:
                longest = llen
        return longest


    def note2num(self, note):
        ''' convert note to number '''
        # all possible notes for changing to a number
        pool = "aAbBCdDeEFgG"
        nt = note[0]
        nn = pool.find(nt, 1)
        if "#" in note:
            nn = nn + 1
            if nn > 11:
                nn = nn - 12
        if "b" in note:
            nn = nn - 1
        return nn

    def shiftkey(self, off, key):
        # take key and return a shifted key with the right # or flat
        #   if a minor

        # list of keys that use flats
        flat = "abdeFg"
        # all possible notes for changing to a number
        pool = "aAbBCdDeEFgG"
        if not key[0] in pool:
            return 'Z'
        # possible flats
        lower = "abdeg"
        #newnote = note # not used?
        ofs = int(off)
        Fl = False
        kn = ChordPro.note2num(self, key)
        # correct for minor
        if "m" in key:
            kn = kn + 3
        # new key after offset
        kn = kn + ofs
        if kn > 11:
            kn = kn - 12
        elif kn < 0:
            kn = kn + 12
        elif kn > 23:
            kn = kn - 24
        nk = pool[kn]
        # determine if new key uses flats or sharps
        if nk in flat:
            Fl = True
        minor = ""
        if "m" in key:
            minor = "m"
            # move back to rel minor
            kn = kn - 3
            if kn < 0:
                kn = kn + 12
            nk = pool[kn]
        ext = ""
        if nk in lower:
            if Fl:
                kn = kn + 1
                if kn > 11:
                    kn = kn - 12
                ext = "b"
            else:
                kn = kn - 1
                if kn < 0:
                    kn = kn + 12
                ext = "#"
        nk = pool[kn]
        return f"{nk}{ext}{minor}"

    def shiftnote(self, note, off, key):
        # take note and return a shifted note right for new key
        # list of keys that use flats
        flat = "abdeFg"
        # all possible notes for changing to a number
        pool = "aAbBCdDeEFgG"
        # pool shifted so relative minor shows major
        mpool = "FgGaAbBCdDeE"
        if not note[0] in pool:
            return 'Z'
        # possible flats
        lower = "abdeg"
        #newnote = note # not used?
        ofs = int(off)
        Fl = False
        kn = ChordPro.note2num(self, key)
        # correct for minor
        if "m" in key:
            kn = kn + 3
        # new key after offset
        kn = kn + ofs
        if kn > 11:
            kn = kn - 12
        elif kn < 0:
            kn = kn + 12
        if kn > 23:
            kn = kn - 24
        nk = pool[kn]
        # determine if new key uses flats or sharps
        if nk in flat:
            Fl = True
        # do the same for the real note now
        nn = ChordPro.note2num(self, note)
        nn = nn + ofs
        if nn > 11:
            nn = nn - 12
        elif nn < 0:
            nn = nn + 12
        ext = ""
        nt = pool[nn]
        if nt in lower:
            if Fl:
                nn = nn + 1
                if nn > 11:
                    nn = nn - 12
                ext = "b"
            else:
                nn = nn - 1
                if nn < 0:
                    nn = nn + 12
                ext = "#"
        nt = pool[nn]
        return f"{nt}{ext}"

    def toHtml(self, strng, winht, offset, columns, zoom):
        ''' take strng and return converted to html,
        R_db is config, offset is transpose and onecolumn on True
        will produce just one column for printing, otherwise we want
        any one column to fit the widget height'''
        global config
        # columns:
        #   0 == normal horizontal paging
        #       use window height
        #   1 == one column for vertical paging or printing
        #       use USletter height
        #   2 == two column for printing
        #       if width X 2 > USletter width, force 1
        #       416 is half wide in px
        state = config['state']
        rawwide = ChordPro.getlongline(self, strng)
        wide = rawwide * zoom * 7
        print(f"tohtml height: {str(winht)} wide: {str(wide)}")
        if int(columns) == 2 and wide > 400:
             # text is too wide single column it (400 is top with margin 0)
             print(f"columns are too wide for two.")
             columns = 1
        # top of file
        hfile = '<html>\n<head>\n<meta charset="utf-8">\n'
        hfile = f'{hfile}<link rel="stylesheet" href="chordpro.css">'
        hfile = f"{hfile}\n</head>\n<body>"
        if int(columns) != 1:
            hfile = f'{hfile}\n<table class="doc"><tr class="pages">'
        #winht = int(state['boxheight'])
        key = state['key']
        height = 0.0
        rpages = 1
        pagetop = False
        titl = True
        buf = io.StringIO(strng)
        for line in buf:
            testl = line.lower()
            rh, dmy = ChordPro.rowheight(self, 'songline', zoom)
            if height > (winht - rh - 0):
                # page full, always need one song line height left
                if int(columns) == 1:
                    rpages = 1
                    hfile = f'{hfile}<div class="page-break"></div>'
                    height = 0.0
                    continue
                hfile = f'{hfile}\n</td>'
                pagetop = False
                height = 0.0
                rpages = rpages + 1
                if int(columns) == 2 and rpages == 3:
                    rpages = 1
                    hfile = f'{hfile}\n</table>'
                    hfile = f'{hfile}<div class="page-break"></div>'
                    hfile = f'{hfile}\n<table class="doc"><tr class="pages">'
            if not pagetop:
                hfile = f'{hfile}\n<td class="page">'
                pagetop = True
            if '{t' in testl and titl:
                st = line.find(":") + 1
                end = line.find("}")
                titl = False
                txt = line[st:end].strip()
                ht, dmy = ChordPro.rowheight(self, 'title', zoom)
                hfile = f'{hfile}\n<div class="title">{txt}</div>'
            elif '{st' in testl or '{sub' in testl:
                st = line.find(":") + 1
                end = line.find("}")
                txt = line[st:end].strip()
                ht, dmy = ChordPro.rowheight(self, 'subtitle', zoom)
                if len(txt) > rawwide:
                    splt = txt.find(' ', rawwide - 15)
                    txt1 = txt[0:splt]
                    txt = txt[splt:]
                    ht = ht + ht
                    hfile = f'{hfile}\n<div class="subtitle">{txt1}</div>'
                hfile = f'{hfile}\n<div class="subtitle">{txt}</div>'
            elif '{auth' in testl or '{art' in testl:
                st = line.find(":") + 1
                end = line.find("}")
                txt = line[st:end].strip()
                ht, dmy = ChordPro.rowheight(self, 'subtitle', zoom)
                hfile = f'{hfile}\n<div class="subtitle">{txt}</div>'
            elif '{c:' in testl or 'comment' in testl:
                st = line.find(":") + 1
                end = line.find("}")
                txt = line[st:end].strip()
                ht, dmy = ChordPro.rowheight(self, 'comment', zoom)
                hfile = f'{hfile}\n<div class="comment">{txt}</div>'
            elif line == "\n":
                ht, dmy = ChordPro.rowheight(self, 'blank', zoom)
                hfile = f'{hfile}\n<div class="blank">&nbsp;</div>'
            elif '{' in line:
                # ToDo deal with other directives
                # separate out lines that  start with "{" so that
                # some other directive, Toss for now
                continue
            elif line[0] == "#":
                # throw hidden lines away too
                continue
            elif '{copy' in testl or 'Â©' in testl or '(c)' in testl:
                if columns == 0 and height > (winht / 2):
                    # FIXME (c) cutoff height
                    # because these can be quite long, start new page
                    #   if we are more than half way down
                    hfile = f'{hfile}\n</td>'
                    height = 0.0
                    state['pages'] = str(int(state['pages']) + 1)
                    hfile = f'{hfile}\n<td class="page">'
                txt = line
                if '{copy' in testl:
                    st = line.find(":") + 1
                    end = line.find("}")
                    txt = line[st:end]
                hite, dmy = ChordPro.rowheight(self, 'subtitle', zoom)
                ht = 0
                while len(txt) > rawwide:
                    splt = txt.find(' ', rawwide - 15)
                    txt1 = txt[0:splt]
                    txt = txt[splt:]
                    ht = hite + ht
                    hfile = f'{hfile}\n<div class="subtitle">{txt1}</div>'
                ht = hite + ht
                hfile = f'{hfile}\n<div class="subtitle">{txt}</div>'
            else:
                # height should be songline
                ht, dmy = ChordPro.rowheight(self, 'songline', zoom)
                hfile = f'{hfile}\n<table class="songline">'
                cline = '\n<tr class="chords">'
                lline = '\n<tr class="lyrics">'
                ourline = line.strip()
                if columns > 0 and eval(config['pdf']['lyrics']):
                    ourline = UserConfig.deChordLine(ourline)
                if ourline.find("[") == -1:
                    # if no chords, height = lyrics
                    ht, dmy = ChordPro.rowheight(self, 'lyrics', zoom)
                for sub in ourline.split('['):
                    # each sub has either one ] or none
                    if sub == "":
                        # line begins with [ so empty sub skip
                        continue
                    pre, bra, tail = sub.partition("]")
                    if bra == "":
                        #whole thing should be text, no chords
                        cline = f"{cline}<td> </td>"
                        lspace = pre.replace(' ', '&nbsp;')
                        lline = f"{lline}<td>{lspace} </td>"
                    elif not tail == "" and tail[0] == " ":
                        # lyric does not start under chord
                        pre = ChordPro.getOffset(self, pre, offset, key)
                        cline = f"{cline}<td>{pre} </td><td> </td>"
                        lspace = tail.replace(' ', '&nbsp;')
                        lline = f"{lline}<td> </td><td>{lspace} </td>"
                    else:
                        pre = ChordPro.getOffset(self, pre, offset, key)
                        cline = f"{cline}<td>{pre} </td>"
                        lspace = tail.replace(' ', '&nbsp;')
                        lline = f"{lline}<td>{lspace} </td>"
                cline = f"{cline}</tr>\n"
                lline = f"{lline}</tr>\n"
                hfile = f'{hfile}{cline}{lline}\n</table>'
            height = height + ht
        hfile = f"{hfile}</tr></table></body></html>\n"
        state['pages'] = rpages
        return hfile


class NewSetDialog(Gtk.Dialog):

    def __init__(self, parent):
        super().__init__(title="Add New Set List", parent=window)
        self.add_buttons(
            Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL, Gtk.STOCK_OK, Gtk.ResponseType.OK
        )
        self.set_default_size(150, 100)

        label = Gtk.Label(label="Enter name for setlist")
        entry = Gtk.Entry()
        entry.set_buffer(newsetbuff)
        box = self.get_content_area()
        box.add(label)
        box.add(entry)
        entry.connect("activate", self.submit)
        self.show_all()

    def submit(self, entry):
        # Send the OK response to the dialog
        self.response(Gtk.ResponseType.OK)


class SearchDialog(Gtk.Dialog):

    def __init__(self, parent):
        super().__init__(title="Search For A Song", parent=window)
        self.add_buttons(Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL)
        self.set_default_size(700, 500)
        self.filePath = "none"
        self.found = {}
        # Input section:
        label = Gtk.Label(label="Search Text:")
        entry = Gtk.Entry()
        srchBox = Gtk.Box()
        srchBox.set_orientation(Gtk.Orientation.HORIZONTAL)
        srchBox.pack_start(label, expand = False, fill = False, padding = 10)
        srchBox.pack_start(entry, expand = True, fill = True, padding = 10)
        # List section
        self.listbx = Gtk.ListBox()
        vp = Gtk.Viewport()
        vp.add(self.listbx)
        Scrlbx = Gtk.ScrolledWindow()
        Scrlbx.add(vp)
        # box to fit everything in
        box = self.get_content_area()
        box.add(srchBox)
        box.pack_start(Scrlbx, expand = True, fill = True, padding = 0)
        self.listbx.connect("row-selected", self.submit)
        entry.connect("changed", self.fillList)
        self.show_all()

    def fillList(self, widget):
        global config
        self.found = {}
        srchtxt = widget.get_text().lower()
        if len(srchtxt) < 4:
            self.dsplylist()
            return
        #remove spaces and non-letter chars
        srch = re.sub(r'[^a-zA-Z0-9]', '', srchtxt)
        songfile = f"{config['state']['config_path']}/songs.json"
        if os.path.isfile(songfile) and os.path.getsize(songfile) > 50:
            # songfile file exists, read it in
            with open(songfile) as f:
                sdb = json.load(f)
            indx = 0
            for sfile in sdb:
                fnd = False
                linetx = ""
                # TODO search against author too
                sn = re.sub(r'[^a-zA-Z0-9]', '', sdb[sfile]['name'])
                if srch in sn:
                    fnd = True
                sv = re.sub(r'[^a-zA-Z0-9]', '', sdb[sfile]['verse'])
                sc = re.sub(r'[^a-zA-Z0-9]', '', sdb[sfile]['chorus'])
                si = re.sub(r'[^a-zA-Z0-9]', '', sdb[sfile]['number'])
                if srch in si:
                    fnd = True
                if srch in sv:
                    linetx = sdb[sfile]['verse']
                    fnd = True
                elif srch in sc:
                    linetx = sdb[sfile]['chorus']
                    fnd = True
                if fnd:
                    self.found[str(indx)] = {
                            'file': sfile,
                            'name': sdb[sfile]['name'],
                            'author': sdb[sfile]['author'],
                            'line': linetx,
                            'number': sdb[sfile]['number']
                        }
                    indx = indx + 1
        self.dsplylist()

    def dsplylist(self):
        each = None
        while self.listbx.get_row_at_index(0):
            each = self.listbx.get_row_at_index(0)
            each.destroy()
        if self.found != {}:
            for idx in self.found:
                mysng = self.found[idx]
                desc = f"{os.path.basename(mysng['file'])}\n"
                desc = f"{desc}{mysng['name']} - {mysng['author']}"
                desc = f"{desc} - {mysng['number']}\n"
                desc = f"{desc}{mysng['line']}"
                label = Gtk.Label.new(desc)
                label.set_justify(Gtk.Justification.LEFT)
                row = Gtk.ListBoxRow()
                hbox = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=50)
                row.add(hbox)
                hbox.pack_start(label, False, False, 0)
                self.listbx.add(row)
                label.show()
                self.listbx.show_all()

    def submit(self, widget, row):
        global config
        global srchfil
        srchfil = 'none'
        state = config['state']
        # A song was selected from the list
        if row == None:
            return
        idx = str(row.get_index())
        srchfil = self.found[idx]['file']
        # Send the OK response to the dialog
        self.response(Gtk.ResponseType.OK)


class OKCancelDialog(Gtk.Dialog):

    def __init__(self, parent):
        super().__init__(title="Remove Set List", parent=window)
        self.add_buttons(
            Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL, Gtk.STOCK_OK, Gtk.ResponseType.OK
        )
        self.set_default_size(150, 100)

        label = Gtk.Label(label="Remove list: are you sure")
        box = self.get_content_area()
        box.add(label)
        self.show_all()

class notSavedDialog(Gtk.Dialog):

    def __init__(self, parent):
        super().__init__(title="Song Changed", parent=window)
        self.add_buttons(
            Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL, Gtk.STOCK_OK, Gtk.ResponseType.OK
        )
        self.set_default_size(150, 100)

        label = Gtk.Label(label="Current Song Changed, Save?")
        box = self.get_content_area()
        box.add(label)
        self.show_all()

class GetKeyDialog(Gtk.Dialog):

    def __init__(self, parent):
        super().__init__(title="Key Detect", parent=window)
        self.add_buttons(Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL,
                        Gtk.STOCK_DELETE, Gtk.ResponseType.DELETE_EVENT)
        self.set_default_size(150, 100)
        self.ourkey = 0
        label = Gtk.Label(label="Waiting for Key or Pedal Press")
        box = self.get_content_area()
        box.add(label)
        self.connect("key-press-event", self.submit)
        self.show_all()

    def submit(self, widget, event):
        # get event
        keyname = Gdk.keyval_name(event.keyval)
        self.ourkey = event.keyval
        self.response(Gtk.ResponseType.OK)
        return True

class MidiInputHandler(object):
    def __init__(self, port):
        global config
        self.db = config['midi']
        self.port = port
        self._wallclock = time.time()

    def __call__(self, event, data=None):
        global midi_dial
        event, deltatime = event
        self._wallclock += deltatime
        rvalid = True
        if event[0] < 0xF0:
            status = event[0] & 0xF0
        else:
            status = event[0]
        if status == POLY_PRESSURE or status == CHANNEL_PRESSURE or status == PITCH_BEND:
                #print("POLY_PRESSURE, CHANNEL_PRESSURE and PITCH_BEND not used")
                return
        if status == NOTE_OFF:
            revent = [event[0], event[1]]
        elif status == NOTE_ON:
            if event[2] == 0:
                # bogus note off
                return
            revent = [event[0], event[1]]
        else:
            revent = event
        if "true" in self.db['select']:
            print("midi in select mode")
            self.db['choice'] = str(revent)
            print(f"choice: {self.db['choice']}")
            midi_dial.response(Gtk.ResponseType.OK)
            self.db['select'] = "false"
        else:
            self.db['cmd'] = str(revent)


class GetMIDIDialog(Gtk.Dialog):

    def __init__(self, parent):
        super().__init__(title="MIDI Detect", parent=window)
        global config
        config['midi']['select'] = "true"
        self.add_buttons(Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL,
                        Gtk.STOCK_DELETE, Gtk.ResponseType.DELETE_EVENT)
        self.set_default_size(150, 100)
        label = Gtk.Label(label="Waiting for Key or Pedal Press")
        box = self.get_content_area()
        box.add(label)
        self.show_all()

class UserConfig():

    def __init__(self):
        global config
        global lists_db
        config_path = os.path.expanduser(f"~/.config/{appname}/")
        pdfpath = f"{config_path}pdf/"
        # Make sure this directory exists (makes config_path too)
        if not os.path.isdir(pdfpath):
            os.makedirs(pdfpath)
        c_file = f"{config_path}/{appname}.json"
        if os.path.isfile(c_file) and os.path.getsize(c_file) > 100:
            # config file exists, read it in
            with open(c_file) as f:
                config = json.load(f)
        else:
            print(f"{c_file} not found. Make one.")
            # Our config db has:
            #       general - Misc params
            #       webkit  - this is how our chart looks
            #       hotkeys - Chart display hot keys
            #       midi    - Allows midi events as hot keys
            #       pdf     - settings for pdf saving
            #       state   - What is going on right now
            #### Line below is important, creates our db
            config = {'version': "1.2.0"}
        if not 'state' in config:
            config['state'] = {'key': "unknown"}
        state_db = config['state']
        state_db['dirty'] = False # just started nothing saveable
        state_db['song'] = "0" # song number in list
        state_db['inlist'] = "false"
        state_db['pages'] = "1" # pages in this song
        state_db['page'] = "1" # page in this song
        state_db['file'] = "none" # current song file name
        if not 'config_path' in state_db:
            state_db['config_path'] = config_path
        state_db['list'] = "0" # current list number
        state_db['offset'] = "0" # key offset of current song
        if not 'main_x' in state_db:
            state_db['main_x'] = "1900" # main window width
        if not 'main_y' in state_db:
            state_db['main_y'] = "1000" # main window height
        if not 'boxheight' in state_db:
            state_db['boxheight'] = '850'

        # stuff to do with webkit chart.
        if not 'webkit' in config:
            config['webkit'] = {'zoom': "200"}
        webdb = config['webkit']
        if not 'title' in webdb:
            webdb['title'] = {'size': "100", 'color': "black"}
        if not 'subtitle' in webdb:
            webdb['subtitle'] = {'size': "75", 'color': "black"}
        if not 'comment' in webdb:
            webdb['comment'] = {'size': "90", 'color': "black"}
        if not 'chords' in webdb:
            webdb['chords'] = {'size': "88", 'color': "red"}
        if not 'lyrics' in webdb:
            webdb['lyrics'] = {'size': "80", 'color': "black"}

        if not 'general' in config:
            config['general'] = {'edzoom': "200"}
        gendb = config['general']
        if not 'chrtcol' in gendb:
            gendb['chrtcol'] = "1"
        if not 'folder' in gendb:
            gendb['folder'] = os.path.expanduser(f"~/")
        if not 'folderdepth' in gendb:
            gendb['folderdepth'] = "1"
        if not 'pagesize' in gendb:
            gendb['pagesize'] = "816" #width px
        if not 'autosong' in gendb:
            gendb['autosong'] = 'False'

        if not 'hotkeys' in config:
            # 6 is used but ^ is thought
            config['hotkeys'] = {'keyup': "6"}
        hotdb = config['hotkeys']
        if not 'keydown' in hotdb:
            hotdb['keydown'] = "v"
        if not 'pagenext' in hotdb:
            hotdb['pagenext'] = "c"
        if not 'pageback' in hotdb:
            hotdb['pageback'] = "a"
        if not 'songnext' in hotdb:
            hotdb['songnext'] = "b"
        if not 'songback' in hotdb:
            # , looks like <
            hotdb['songback'] = "comma"

        if not 'midi' in config:
            # These are empty
            config['midi'] = {'keyup': "#"}
        mididb = config['midi']
        if not 'keydown' in mididb:
            mididb['keydown'] = "#"
        if not 'pagenext' in mididb:
            mididb['pagenext'] = "#"
        if not 'pageback' in mididb:
            mididb['pageback'] = "#"
        if not 'songnext' in mididb:
            mididb['songnext'] = "#"
        if not 'songback' in mididb:
            mididb['songback'] = "#"
        if not 'device' in mididb:
            mididb['device'] = "none"
        if not 'backend' in mididb:
            mididb['backend'] = "alsa"
        mididb['select'] = "false"
        mididb['choice'] = ""
        mididb['port'] = "none"
        mididb['cmd'] = "none"

        if not 'pdf' in config:
            # These are empty
            config['pdf'] = {'folder': os.path.expanduser(f"~/")}
        pdfdb = config['pdf']
        if not 'columns' in pdfdb:
            pdfdb['columns'] = "1"
        if not 'lyrics' in pdfdb:
            pdfdb['lyrics'] = "False"
        if not 'zoom' in pdfdb:
            pdfdb['zoom'] = "100"
        if not 'colour' in pdfdb:
            pdfdb['colour'] = "False"
        # FIXME pdf height
        #boxht = 1056 # 1056 is supposed to be std :P
        # 1196 current working number
        pdfdb['height'] = 1196
        #print(f"lyrics eval: {str(eval(pdfdb['lyrics']))}")

        pdffoldersel.set_current_folder(pdfdb['folder'])
        pdfcoldrop.set_active_id(pdfdb['columns'])
        pdflyricsonly.set_active(eval(pdfdb['lyrics']))
        pdfzoomspin.set_value(int(pdfdb['zoom']))
        pdfcolourch.set_active(eval(pdfdb['colour']))

        stylezoom.set_sensitive(False)
        styletitlesz.set_sensitive(False)
        stylesubtsz.set_sensitive(False)
        stylechordsz.set_sensitive(False)
        stylelyricsz.set_sensitive(False)
        stylecommentsz.set_sensitive(False)
        styletitleclr.set_sensitive(False)
        stylesubtclr.set_sensitive(False)
        stylechordclr.set_sensitive(False)
        stylelyricclr.set_sensitive(False)
        stylecommentclr.set_sensitive(False)
        stylezoom.set_value(int(webdb['zoom']))
        styletitlesz.set_value(int(webdb['title']['size']))
        stylesubtsz.set_value(int(webdb['subtitle']['size']))
        stylechordsz.set_value(int(webdb['chords']['size']))
        stylelyricsz.set_value(int(webdb['lyrics']['size']))
        stylecommentsz.set_value(int(webdb['comment']['size']))
        styletitleclr.set_active_id(webdb['title']['color'])
        stylesubtclr.set_active_id(webdb['subtitle']['color'])
        stylechordclr.set_active_id(webdb['chords']['color'])
        stylelyricclr.set_active_id(webdb['lyrics']['color'])
        stylecommentclr.set_active_id(webdb['comment']['color'])
        stylezoom.set_sensitive(True)
        styletitlesz.set_sensitive(True)
        stylesubtsz.set_sensitive(True)
        stylechordsz.set_sensitive(True)
        stylelyricsz.set_sensitive(True)
        stylecommentsz.set_sensitive(True)
        styletitleclr.set_sensitive(True)
        stylesubtclr.set_sensitive(True)
        stylechordclr.set_sensitive(True)
        stylelyricclr.set_sensitive(True)
        stylecommentclr.set_sensitive(True)
        basefoldersel.set_current_folder(gendb['folder'])
        folderdepth.set_sensitive(False)
        folderdepth.set_value(int(config['general']['folderdepth']))
        folderdepth.set_sensitive(True)
        autosong.set_sensitive(False)
        if 'True' in config['general']['autosong']:
            autosong.set_active(True)
        autosong.set_sensitive(True)
        getpn.set_label(config['hotkeys']['pagenext'])
        getpb.set_label(config['hotkeys']['pageback'])
        getsn.set_label(config['hotkeys']['songnext'])
        getsb.set_label(config['hotkeys']['songback'])
        getku.set_label(config['hotkeys']['keyup'])
        getkd.set_label(config['hotkeys']['keydown'])

        midipn.set_label(config['midi']['pagenext'])
        midipb.set_label(config['midi']['pageback'])
        midisn.set_label(config['midi']['songnext'])
        midisb.set_label(config['midi']['songback'])
        midiku.set_label(config['midi']['keyup'])
        midikd.set_label(config['midi']['keydown'])
        midiapidrop.set_active_id(config['midi']['backend'])

        # load setlist
        list_file = f"{config_path}/setlist.json"
        if os.path.isfile(list_file) and os.path.getsize(list_file) > 20:
            # set list file exists, read it in
            with open(list_file) as f:
                lists_db = json.load(f)
        else:
            print("no set list file, make blank db.")
            lists_db = {}
        state_db['list'] = "0"
        self.setselectfix()
        self.midireset()
        self.mididevicelist()
        self.save_webcss()
        self.sethotkeys()
        self.midiopen()
        self.Save()

    def setselectfix(self):
        global config
        global lists_db
        setselecter.set_sensitive(False)
        setselecter.remove_all()
        setselecter.append("0", "None")
        for x in lists_db:
            name = lists_db[x]['listname']
            setselecter.append(x, name)
        setselecter.set_active_id(config['state']['list'])
        setselecter.set_sensitive(True)

    def midireset(self):
        global config
        global midiin
        backend = config['midi']['backend']
        if 'midiin' in globals():
            if midiin.is_port_open():
                midiin.close_port()
                midiin.delete()
        if backend == 'alsa':
            ourapi = rtmidi.API_LINUX_ALSA
        elif backend == 'jack':
            ourapi = rtmidi.API_UNIX_JACK
        else:
            ourapi = rtmidi.API_UNSPECIFIED
        midiin = rtmidi.MidiIn(rtapi=ourapi, name=appname)
        return ourapi

    def mididevicelist(self):
        global config
        global midiin
        condev = config['midi']['device']
        mididevice.set_sensitive(False)
        mididevice.remove_all()
        mididevice.append("none", "No MIDI port")
        mididevice.append("no_connection", "Open MIDI port- no connection")
        if condev == 'none':
            mididevice.set_active(0)
        elif condev == 'no_connection':
            mididevice.set_active(1)
        else:
            mididevice.append(condev, condev)
            mididevice.set_active(2)
        ports = range(midiin.get_port_count())
        for x in ports:
            devraw = midiin.get_port_name(x)
            thsdev = devraw[0:devraw.rfind(" ")]
            if condev in thsdev:
                break
            mididevice.append(thsdev, thsdev)
        mididevice.set_sensitive(True)

    def midiopen(self):
        global config
        global midiin
        rport = config['midi']['device']
        oport = config['midi']['port']
        if rport == 'none':
            return
        if rport == oport:
            # we're already open
            return
        ourapi = UserConfig.midireset(self)
        validport = False
        useport = None
        ports = range(midiin.get_port_count())
        for x in ports:
            thsdev = midiin.get_port_name(x)
            if rport in thsdev:
                validport = True
        if not validport:
            UserConfig.showStatus(self, "MIDI device not available -not connected")
        else:
            useport = rport

        try:
            midiin, port_name = open_midiinput(
                useport,
                use_virtual=True,
                api=ourapi,
                client_name='musicpager',
                port_name='MIDI_input')
        except (IOError, ValueError) as exc:
            return "Could not open MIDI input: %s" % exc
        oport = rport
        midiin.set_callback(MidiInputHandler(port_name))

    def fillsonglist(self):
        global config
        global lists_db
        state = config['state']
        placeholder = 'unknown'

        # clear out list
        each = None
        while songlist.get_row_at_index(0):
            each = songlist.get_row_at_index(0)
            each.destroy()
        mainsongsel.remove_all()
        mainsongsel.append("name", "thinking")
        mainsongsel.append("load", "Load File")
        mainsongsel.append("search", "Search For Text")
        mainsongsel.append("add", "Add song to List")

        if state['list'] == "0":
            print("no list")
            return
        if len(lists_db[state['list']]['songs']) < 1:
            print("not even one song in this list")
            return
        for idx in lists_db[state['list']]['songs']:
            song_db = lists_db[state['list']]['songs'][idx]
            if os.path.isfile(song_db['file']):
                with open(song_db['file'], encoding="utf-8") as f:
                    read_data = f.read()
                if read_data.lower().find("{t:") == -1:
                    if read_data.lower().find("{title:") == -1:
                        # no title
                        base = os.path.basename(state['file'])
                        name = base.split(".")[0]
                    else:
                        name = read_data[read_data.lower().find("{title:")+7:].split("}",1)[0].strip()
                else:
                    name = read_data[read_data.lower().find("{t:")+3:].split("}",1)[0].strip()
                if read_data.lower().find("{key:") == -1:
                    if read_data.lower().find("# key") == -1:
                        # no key
                        key = placeholder
                    else:
                        key1 = read_data[read_data.lower().find("# key = ") + 8:]
                        key = key1.split("\n",1)[0].strip()
                else:
                    key = read_data[read_data.lower().find("{key:")+5:].split("}",1)[0].strip()
                if read_data.lower().find("{composer:") == -1:
                    if read_data.lower().find("{artist:") == -1:
                        if read_data.lower().find("{subtitle:") == -1:
                            if read_data.lower().find("{st:") == -1:
                                print(" no author")
                                author = placeholder
                            else:
                                author = read_data[read_data.lower().find("{st:")+4:].split("}",1)[0].strip()
                        else:
                            author = read_data[read_data.lower().find("{subtitle:")+10:].split("}",1)[0].strip()
                    else:
                        author = read_data[read_data.lower().find("{artist:")+8:].split("}",1)[0].strip()
                else:
                    author = read_data[read_data.lower().find("{composer:")+10:].split("}",1)[0].strip()
                desc = f"{idx}: {name} - {author} - "
                mainsongsel.append(str(idx), name)
                dkey = ChordPro.shiftkey(self, song_db['offset'], key)
                if dkey != 'Z':
                    desc = f"{desc}Key: {dkey}({key})"
            else:
                desc = f"{idx}: File Missing: {song_db['file']}"
                mainsongsel.append(str(idx), "File Missing")
            label = Gtk.Label.new(desc)
            label.set_justify(Gtk.Justification.LEFT)
            row = Gtk.ListBoxRow()
            hbox = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=50)
            row.add(hbox)
            hbox.pack_start(label, False, False, 0)
            songlist.add(row)
            label.show()
            songlist.show_all()
        UserConfig.fixsonginfo(self)

    def fixsonginfo(self):
        global config
        state = config['state']
        edtxst = edit_text.get_start_iter()
        edtxend = edit_text.get_end_iter()
        our_text = edit_text.get_text(edtxst, edtxend, False )
        if our_text.lower().find("{t:") == -1:
            if our_text.lower().find("{title:") == -1:
                # no title
                base = os.path.basename(state['file'])
                sname = base.split(".")[0]
            else:
                sname = our_text[our_text.lower().find("{title:")+7:].split("}",1)[0].strip()
        else:
            sname = our_text[our_text.lower().find("{t:")+3:].split("}",1)[0].strip()
        if our_text.lower().find("{k") == -1:
            if our_text.lower().find("# key") == -1:
                state['key'] = "unknown"
            else:
                ke1 = our_text[our_text.lower().find("# key = ") + 8:]
                state['key'] = ke1.split("\n",1)[0].strip()
        else:
            key1 = our_text[our_text.lower().find("{k"):]
            state['key'] = key1.split(": ")[1].split("}",1)[0].strip()
        newkey = state['key']
        if state['offset'] != '0':
            newkey = ChordPro.shiftkey(self, state['offset'], state['key'])
        if state['key'] == "unknown":
            newkey = state['key']
        if state['file'] == "none":
            sname = "none"
        mainkeysign.set_text(f"Key: {newkey}/({state['key']})")
        mainsongsel.remove(0)
        mainsongsel.prepend("name", sname)
        mainsongsel.set_active_id("name")

    def loadsong(self):
        global config
        global lists_db
        state = config['state']
        state['page'] = 1
        if not os.path.isfile(state['file']):
            read_data = f"File: {state['file']} Is missing!"
        if state['file'] == 'none':
            read_data = ""
        else:
            with open(state['file'], encoding="utf-8") as f:
                read_data = f.read()
        lngln = ChordPro.getlongline(self, read_data)
        zm = float(config['webkit']['zoom'])/100
        config['general']['pagesize'] = lngln * 7 * zm
        UserConfig.save_webcss(self, lngln)
        if state['list'] != "0" and state["song"] != "0":
            # offset should always come from list db as different
            # lists might have the same song in a different key
            song_db = lists_db[state['list']]['songs'][state['song']]
            state['offset'] = song_db['offset']
            if not 'notes' in song_db:
                song_db['notes'] = ""
            songnotes = song_db['notes']
        else:
            state['offset'] = "0"
            songnotes = ""
            if read_data.lower().find("# trans") != -1:
                os1 = read_data[read_data.lower().find("# transpose = ") + 14:]
                state['offset'] = os1.split("\n",1)[0].strip()
            if read_data.lower().find("# songnotes") != -1:
                sn = read_data[read_data.lower().find("# songnotes = ") + 14:]
                songnotes = sn.split("\n",1)[0].strip()
        if read_data.lower().find("{t:") == -1:
            if read_data.lower().find("{title:") == -1:
                # no title
                base = os.path.basename(state['file'])
                sname = base.split(".")[0]
            else:
                sname = read_data[read_data.lower().find("{title:")+7:].split("}",1)[0].strip()
        else:
            sname = read_data[read_data.lower().find("{t:")+3:].split("}",1)[0].strip()
        if read_data.lower().find("{k") == -1:
            if read_data.lower().find("# key") == -1:
                state['key'] = "unknown"
            else:
                ke1 = read_data[read_data.lower().find("# key = ") + 8:]
                state['key'] = ke1.split("\n",1)[0].strip()
        else:
            key1 = read_data[read_data.lower().find("{k"):]
            state['key'] = key1.split(": ")[1].split("}",1)[0].strip()
        mydirty = False
        if state['key'] == "unknown":
            print("try to guess key")
            state['key'] = ChordPro.keyguess(self, read_data)
            if state['key'] != "unknown":
                read_data = f"{read_data}\n# key = {state['key']}\n\n"
                mydirty = True
        edit_text.set_text(read_data)
        enternotes.set_text(songnotes)
        adj = webkitbox.get_hadjustment()
        adj.set_value(0.0)
        rdmanbut.set_active(False)
        Handler.refreshChart(self)
        state['dirty'] = mydirty

    def save_setlist(self):
        global config
        global lists_db
        state = config['state']
        # Save setlist
        list_file = f"{state['config_path']}/setlist.json"
        with open(list_file, 'w') as json_file:
            if json_file.writable():
                fcntl.lockf(json_file, fcntl.LOCK_EX)
            json.dump(lists_db, json_file, indent=4)
            json_file.write("\n")
            json_file.flush()
            os.fsync(json_file.fileno())
            # Release the lock on the file.
            if json_file.writable():
                fcntl.lockf(json_file, fcntl.LOCK_UN)


    def Save(self):
        global config
        global lists_db
        state = config['state']
        # this should get called any time we leave the settings page
        c_file = f"{state['config_path']}/{appname}.json"
        with open(c_file, 'w') as json_file:
            if json_file.writable():
                fcntl.lockf(json_file, fcntl.LOCK_EX)
            json.dump(config, json_file, indent=4)
            json_file.write("\n")
            json_file.flush()
            os.fsync(json_file.fileno())
            # Release the lock on the file.
            if json_file.writable():
                fcntl.lockf(json_file, fcntl.LOCK_UN)

    def save_webcss(self, pagewide=60 ):
        global config
        state = config['state']
        web = config['webkit']
        pdf = config['pdf']
        css_file = f"{state['config_path']}/chordpro.css"
        pdf_file = f"{state['config_path']}/pdf/chordpro.css"
        # Notes: pdf = US-Letter: 8.5in x 11.0in (816px x 1056px) (96DPI)
        #           The 816 is pretty close
        #           1065 is too small, second page starts on bottom of page 1
        sl = " {"
        ft = " {\n\tfont-size: "
        fte = "px;"
        cl = "px;\n\tcolor: "
        lh = "\n\theight: "
        el = "\n\t}"
        zm = float(web['zoom'])/100
        pzm = float(pdf['zoom'])/100
        fnt = 16 * zm
        pfnt = 16 * pzm
        pst1 = "\n@media print {\n\t.page, .page-break"
        pst2 = " { break-after: page; }\n}"
        str1 = "\n@page {\n\tmargin:6mm\n}"
        str2 = "\n.doc {\n\talign-content: flex-start;\n\t}"
        c_str = f"{str1}{str2}\ntd{sl}\n\tpadding: 0px;{el}"
        c_str = f"{c_str}\ntable{sl}\n\tborder-spacing: 0px;"
        c_str = f"{c_str}{el}"
        # next line started with 816, tohtml uses 800
        p_str = f"{pst1}{pst2}{c_str}\n\tmax_width: 808px;{el}"
        t_str = f"\n.pages{sl}{el}\n.page{sl}\n\tvertical-align: top;"
        c_str = f"{c_str}{t_str}"
        p_str = f"{p_str}{t_str}"
        # next two lines, set 7 to optimum char width
        # also in loadsong
        pgsz = pagewide * zm * 7
        ppgsz = pagewide * pzm * 7
        exra = f"{el}\n.songline{sl}\n\theight: "
        c_str = f"{c_str}\n\tmin-width: {pgsz}px;\n\tmax-width: {pgsz}{exra}"
        p_str = f"{p_str}\n\tmin-width: {ppgsz}px;\n\tmax-width: {ppgsz}{exra}"

        h, f = ChordPro.rowheight(self, "songline", zm)
        c_str = f"{c_str}{f}px;{el}"
        h, f = ChordPro.rowheight(self, "songline", pzm)
        p_str = f"{p_str}{f}px;{el}"
        h, f = ChordPro.rowheight(self, "blank", zm)
        c_str = f"{c_str}\n.blank{sl}\n\theight: {h}px;{el}"
        h, f = ChordPro.rowheight(self, "blank", pzm)
        p_str = f"{p_str}\n.blank{sl}\n\theight: {h}px;{el}"
        # title
        h, f = ChordPro.rowheight(self, "title", zm)
        line = f"\n.title{ft}{f}{cl}{web['title']['color']};"
        line = f"{line}\n\tmax-height: {f}px;{el}"
        c_str = f"{c_str}{line}"
        h, f = ChordPro.rowheight(self, "title", pzm)
        if eval(pdf['colour']):
            line = f"\n.title{ft}{f}{cl}{web['title']['color']};"
        else:
            line = f"\n.title{ft}{f}{cl}black;"
        line = f"{line}\n\tmax-height: {f}px;{el}"
        p_str = f"{p_str}{line}"
        # subtitle
        h, f = ChordPro.rowheight(self, "subtitle", zm)
        line = f"\n.subtitle{ft}{f}{cl}{web['subtitle']['color']};"
        line = f"{line}\n\tmax-height: {f}px;{el}"
        c_str = f"{c_str}{line}"
        h, f = ChordPro.rowheight(self, "subtitle", pzm)
        if eval(pdf['colour']):
            line = f"\n.subtitle{ft}{f}{cl}{web['subtitle']['color']};"
        else:
            line = f"\n.subtitle{ft}{f}{cl}black;"
        line = f"{line}\n\tmax-height: {f}px;{el}"
        p_str = f"{p_str}{line}"
        # comment
        h, f = ChordPro.rowheight(self, "comment", zm)
        line = f"\n.comment{ft}{f}{cl}{web['comment']['color']};"
        line = f"{line}\n\tmax-height: {f}px;{el}"
        c_str = f"{c_str}{line}"
        h, f = ChordPro.rowheight(self, "comment", pzm)
        if eval(pdf['colour']):
            line = f"\n.comment{ft}{f}{cl}{web['comment']['color']};"
        else:
            line = f"\n.comment{ft}{f}{cl}black;"
        line = f"{line}\n\tmax-height: {f}px;{el}"
        p_str = f"{p_str}{line}"
        # chords
        h, f = ChordPro.rowheight(self, "chords", zm)
        line = f"\n.chords{ft}{f}{cl}{web['chords']['color']};"
        line = f"{line}\n\tmax-height: {f}px;{el}"
        c_str = f"{c_str}{line}"
        h, f = ChordPro.rowheight(self, "chords", pzm)
        if eval(pdf['colour']):
            line = f"\n.chords{ft}{f}{cl}{web['chords']['color']};"
        else:
            line = f"\n.chords{ft}{f}{cl}black;"
        line = f"{line}\n\tmax-height: {f}px;{el}"
        p_str = f"{p_str}{line}"
        # lyrics
        h, f = ChordPro.rowheight(self, "lyrics", zm)
        line = f"\n.lyrics{ft}{f}{cl}{web['lyrics']['color']};"
        line = f"{line}\n\tmax-height: {f}px;{el}"
        c_str = f"{c_str}{line}\n\n"
        h, f = ChordPro.rowheight(self, "lyrics", pzm)
        if eval(pdf['colour']):
            line = f"\n.lyrics{ft}{f}{cl}{web['lyrics']['color']};"
        else:
            line = f"\n.lyrics{ft}{f}{cl}black;"
        line = f"{line}\n\tmax-height: {f}px;{el}"
        p_str = f"{p_str}{line}\n\n"
        with open(css_file, 'w', encoding="utf-8") as f:
            f.write(c_str)
        with open(pdf_file, 'w', encoding="utf-8") as f:
            f.write(p_str)

    def saveSongs(self):
        global config
        gen = config['general']
        state = config['state']
        song_file = f"{state['config_path']}/songs.json"
        songDir = gen['folder']
        maxd = int(gen['folderdepth'])
        filelist = []
        dirlist = []
        songdb = {}
        ok_ext = ['.txt', '.crd', '.cho', '.gcp']
        depth = 0
        oldDlist = [songDir]
        for deep in range(0, maxd + 1):
            for dr in oldDlist:
                rawlist = os.listdir(dr)
                for entry in rawlist:
                    epath = f"{dr}/{entry}"
                    if os.path.isfile(epath):
                        filelist = filelist + [epath]
                    if os.path.isdir(epath):
                        dirlist = dirlist + [epath]
            oldDlist = dirlist
        for fullx in filelist:
            xext = "bad"
            xext = os.path.splitext(fullx)[1]
            name = 'unknown'
            author = name
            vline = name
            cline = name
            snum = name
            if xext in ok_ext:
                with open(fullx, encoding="utf-8") as f:
                    read_data = f.read().lower()
                if read_data.find("{") == -1 and read_data.find("[") == -1:
                    # not chordpro song
                    continue
                if read_data.find("{t:") == -1:
                    if read_data.find("{title:") == -1:
                        # no title
                        base = os.path.basename(state['file'])
                        name = base.split(".")[0]
                        name = name.replace('_', ' ')
                        name = name.replace('-', ' ')
                    else:
                        name = read_data[read_data.find("{title:")+7:].split("}",1)[0].strip()
                else:
                    name = read_data[read_data.find("{t:")+3:].split("}",1)[0].strip()
                if read_data.find("{composer:") == -1:
                    if read_data.find("{artist:") == -1:
                        if read_data.find("{subtitle:") == -1:
                            if read_data.find("{st:") == -1:
                                author = 'none'
                            else:
                                author = read_data[read_data.find("{st:")+4:].split("}",1)[0].strip()
                        else:
                            author = read_data[read_data.find("{subtitle:")+10:].split("}",1)[0].strip()
                    else:
                        author = read_data[read_data.find("{artist:")+8:].split("}",1)[0].strip()
                else:
                    author = read_data[read_data.find("{composer:")+10:].split("}",1)[0].strip()
                veridx = read_data.find("verse")
                choidx = read_data.find("chorus")
                if veridx != -1:
                    vline = read_data[veridx:].split("\n", 1)[1].split("\n")[0]
                    vline = UserConfig.deChordLine(vline)
                if choidx != -1:
                    cline = read_data[choidx:].split("\n", 1)[1].split("\n")[0]
                    cline = UserConfig.deChordLine(cline)
                sngidx = read_data.find("song # ")
                if sngidx != -1:
                    snum = read_data[(sngidx + 6):].split("\n", 1)[0]
                songdb[fullx] = {
                    'name': name,
                    'author': author,
                    'verse': vline,
                    'chorus': cline,
                    'number': snum
                    }
        with open(song_file, 'w') as json_file:
            json.dump(songdb, json_file, indent=4)
            json_file.write("\n")
            json_file.flush()

    def deChordLine(line):
        # take [] contents out of line
        out = ""
        for bit in line.split('['):
            if bit.find("]") != -1:
                out = f"{out}{bit.split(']', 1)[1]}"
            else:
                out = f"{out}{bit}"
        return out

    def showStatus(self, messg):
        maininfo.set_text(f"{messg}")

    def forEach(data1, path, key, mod, chng):
        # for testing only
        print(f"path: {str(path)} key: {str(key)}")

    def sethotkeys(self):
        global config
        hot = config['hotkeys']
        Gtk.AccelMap.change_entry(
            "<musicpager>/cht/pagebk",
            Gdk.keyval_from_name(hot['pageback']),
            0,
            True)
        Gtk.AccelMap.change_entry(
            "<musicpager>/cht/pagenx",
            Gdk.keyval_from_name(hot['pagenext']),
            0,
            True)
        Gtk.AccelMap.change_entry(
            "<musicpager>/cht/songbk",
            Gdk.keyval_from_name(hot['songback']),
            0,
            True)
        Gtk.AccelMap.change_entry(
            "<musicpager>/cht/songnx",
            Gdk.keyval_from_name(hot['songnext']),
            0,
            True)
        Gtk.AccelMap.change_entry(
            "<musicpager>/cht/keyup",
            Gdk.keyval_from_name(hot['keyup']),
            0,
            True)
        Gtk.AccelMap.change_entry(
            "<musicpager>/cht/keydn",
            Gdk.keyval_from_name(hot['keydown']),
            0,
            True)

        chrtpb.set_accel_path (
            "<musicpager>/cht/pagebk",
            accelgrp
        )
        chrtpn.set_accel_path (
            "<musicpager>/cht/pagenx",
            accelgrp
        )
        chrtsb.set_accel_path (
            "<musicpager>/cht/songbk",
            accelgrp
        )
        chrtsn.set_accel_path (
            "<musicpager>/cht/songnx",
            accelgrp
        )
        chrtku.set_accel_path (
            "<musicpager>/cht/keyup",
            accelgrp
        )
        chrtkd.set_accel_path (
            "<musicpager>/cht/keydn",
            accelgrp
        )
        # Gtk.AccelMap.foreach(None, UserConfig.forEach) # for testing


class FileChooserWindow(Gtk.Window):

    def __init__(self):

        super().__init__(title="choose Song file")

        box = Gtk.Box(spacing=6)
        self.add(box)
        button1 = Gtk.Button(label="Choose File")
        button1.connect("clicked", self.on_file_clicked)
        box.add(button1)

    def on_file_clicked(self, widget, rfolder=None):
        global config

        dialog = Gtk.FileChooserDialog(
            title="Please choose a file", parent=self, action=Gtk.FileChooserAction.OPEN
        )

        dialog.add_buttons(
            Gtk.STOCK_CANCEL,
            Gtk.ResponseType.CANCEL,
            Gtk.STOCK_OPEN,
            Gtk.ResponseType.OK,

        )
        dialog.set_default_size(800, 400)
        if rfolder == None:
            dialog.set_current_folder(config['general']['folder'])
        else:
            dialog.set_current_folder(rfolder)

        self.add_filters(dialog)
        response = dialog.run()
        if response == Gtk.ResponseType.OK:
            newName = dialog.get_filename()
        elif response == Gtk.ResponseType.CANCEL:
            newName = "none"
        dialog.destroy()
        return newName

    def file_save(self, rfile=None):
        global config
        state = config['state']
        dialog = Gtk.FileChooserDialog(
            title="Please enter file name", parent=self, action=Gtk.FileChooserAction.SAVE
        )
        dialog.add_buttons(
            Gtk.STOCK_CANCEL,
            Gtk.ResponseType.CANCEL,
            Gtk.STOCK_SAVE,
            Gtk.ResponseType.OK,

        )
        dialog.set_default_size(800, 400)
        if rfile == None:
            dialog.set_filename(state['file'])
        else:
            dialog.set_filename(rfile)
        self.add_filters(dialog)
        response = dialog.run()
        if response == Gtk.ResponseType.OK:
            newName = dialog.get_filename()
        elif response == Gtk.ResponseType.CANCEL:
            newName = "none"
        dialog.destroy()
        return newName


    def add_filters(self, dialog):
        filter_cho = Gtk.FileFilter()
        filter_cho.set_name("Chordpro files")
        filter_cho.add_pattern("*.cho")
        filter_cho.add_mime_type("text/plain")
        dialog.add_filter(filter_cho)
        filter_text = Gtk.FileFilter()
        filter_text.set_name("Text files")
        filter_text.add_mime_type("text/plain")
        dialog.add_filter(filter_text)
        filter_any = Gtk.FileFilter()
        filter_any.set_name("Any files")
        filter_any.add_pattern("*")
        dialog.add_filter(filter_any)


class Handler:
    global config
    global lists_db

    def onDestroy(self, *args):
        global config
        global midiin
        if config['state']['dirty']:
            self.askToSave()
        midiin.close_port()
        midiin.delete()
        # restore screen/battery saver
        saver_interface.UnInhibit(blank)
        Gtk.main_quit()

    def onSizeCh(self, *args):
        global config
        state = config['state']
        state['boxheight'] = str(webkitbox.get_allocated_height())
        state['main_x'] = str(window.get_allocated_width())
        state['main_y'] = str(window.get_allocated_height())
        self.refreshChart()
        UserConfig.Save(self)
        return

    #chartview navigation
    def BackPressed(self, button):
        global config
        state = config['state']
        pg = int(state['page'])
        if pg > 1:
            pg = pg - 1
        else:
            if autosong.get_active():
                Handler.PrevSongPressed(self, button)
                return
            else:
                pg = 1
        sz = int(config['general']['pagesize'])
        newpos = float((pg - 1) * sz)
        state['page'] = str(pg)
        adj = webkitbox.get_hadjustment()
        adj.set_value(newpos)

    def ForwardPressed(self, button):
        global config
        state = config['state']
        pg = int(state['page'])
        num = int(state['pages'])
        if pg < num:
            pg = pg + 1
        else:
            if autosong.get_active():
                Handler.NextSongPressed(self, button)
                return
            else:
                pg = num
        sz = int(config['general']['pagesize'])
        state['page'] = str(pg)
        newpos = float((pg - 1) * sz)
        adj = webkitbox.get_hadjustment()
        adj.set_value(newpos)

    def keyup(self, button):
        self.keychange(1)

    def keydown(self, button):
        self.keychange(-1)

    def keychange(self, offset):
        global config
        global lists_db
        state = config['state']
        state['offset'] = str(int(state['offset']) + offset)
        if int(state['list']) > 0:
            song_db = lists_db[state['list']]['songs'][state['song']]
            song_db['offset'] = state['offset']
        Handler.refreshChart(self)
        UserConfig.fillsonglist(self)
        UserConfig.save_setlist(self)

    def PrevSongPressed(self, button):
        global config
        global lists_db
        state = config['state']
        if int(state['list']) == 0:
            UserConfig.showStatus(self, "No List Loaded")
            return
        if state['dirty']:
            self.askToSave()
        if int(state['song']) < 2:
            UserConfig.showStatus(self, "Already At First Song")
            return
        our_db = lists_db[state['list']]['songs']
        if "false" in state['inlist']:
            new = state['song']
            state['inlist'] = "true"
        else:
            new = str(int(state['song']) - 1)
        state['song'] = new
        state['file'] = our_db[new]['file']
        UserConfig.loadsong(self)
        no = len(our_db)
        UserConfig.showStatus(self, f"Song {new} of {str(no)}")

    def ManToggled(self, widget):
        global config
        if widget.get_active():
            state = config['state']
            web = config['webkit']
            gen = config['general']
            manpath = f"{install_path}/share/{appname}/html/"
            manfile = f"{manpath}index.html"
            if not os.path.isfile(manfile):
                read_data = f"Manual File: {state['file']} Is missing!"
            else:
                with open(manfile, encoding="utf-8") as f:
                    newhtml = f.read()
            bwidth = int(state['main_x']) - 30
            webbigBox.set_size_request (bwidth, int(config['state']['boxheight']))
            wview.load_html(newhtml, f"file://{manpath}/")

        else:
            Handler.refreshChart(self)

    def NextSongPressed(self, button):
        global config
        global lists_db
        state = config['state']
        if int(state['list']) == 0:
            UserConfig.showStatus(self, "No List Loaded")
            return
        if state['dirty']:
            self.askToSave()
        our_db = lists_db[state['list']]['songs']
        if "false" in state['inlist']:
            new = state['song']
            state['inlist'] = "true"
        else:
            new = str(int(state['song']) + 1)
        no = len(our_db)
        if int(new) > no:
            UserConfig.showStatus(self, "Already At Last Song")
            return
        state['song'] = new
        state['file'] = our_db[new]['file']
        UserConfig.loadsong(self)
        UserConfig.showStatus(self, f"Song {new} of {str(no)}")

    def text_changed(self, widget):
        global config
        config['state']['dirty'] = True

    def askToSave(self):
        global config
        state = config['state']
        dialog = notSavedDialog(window)
        response = dialog.run()
        if response == Gtk.ResponseType.CANCEL:
            UserConfig.showStatus(self, "Song not saved")
            dialog.destroy()
            return
        dialog.destroy()
        self.songsaveas()
        UserConfig.showStatus(self, "Set List Removed")

    # main window
    def NbookPageChanged(self, widget, child, new_index):
        global settingvisit
        # pages are:
        #   0: Chart
        #   1: Edit
        #   2: Song List
        #   3: Settings
        self.savedirty = False
        if settingvisit and (new_index != 3):
            cnfctl.Save()
        if (new_index == 0):
            self.refreshChart()
        elif (new_index == 3):
            # Pick up any new devices
            UserConfig.mididevicelist(self)
            settingvisit = True

    def refreshChart(self):
        global config
        state = config['state']
        web = config['webkit']
        zm = float(web['zoom'])/100
        gen = config['general']
        if rdmanbut.get_active():
            return
        state['boxheight'] = str(webkitbox.get_allocated_height())
        edtxst = edit_text.get_start_iter()
        edtxend = edit_text.get_end_iter()
        pageStr = edit_text.get_text(edtxst, edtxend, False)
        ofst = state['offset']
        boxht = int(state['boxheight'])
        wide = gen['pagesize']
        newhtml = ChordPro.toHtml(self, pageStr, boxht, ofst, 0, zm)
        bwidth = (int(state['pages']) + 1) * int(config['general']['pagesize'])
        webbigBox.set_size_request (bwidth, int(state['boxheight']))
        # clear cache so that new css will be read
        ctxt = wview.get_context()
        ctxt.clear_cache()
        # Load HTML and CSS
        wview.load_html(newhtml, f"file://{state['config_path']}/")
        UserConfig.fixsonginfo(self)

    def SetSelected(self, widget):
        global config
        global lists_db
        if not widget.get_sensitive():
            return
        state = config['state']
        # Selected a set list
        state['list'] = widget.get_active_id()
        state['song'] = '1'
        newname = widget.get_active_text()
        UserConfig.fillsonglist(self)
        if state['list'] == '0' or not "1" in lists_db[state['list']]['songs']:
            UserConfig.showStatus(self, "Empty Set List")
            state['song'] = '0'
            state['file'] = "none"
            UserConfig.showStatus(self, f"No list chosen")
        else:
            our_db = lists_db[state['list']]['songs']
            state['file'] = our_db[state['song']]['file']
            state['inlist'] = "true"
        UserConfig.loadsong(self)
        UserConfig.showStatus(self, f"Loaded setlist song 1")

    def SongChange(self, widget):
        global config
        global srchfil
        state = config['state']
        if widget.get_active() > 3:
            indx = widget.get_active_id()
            state['song'] = str(indx)
            state['file'] = lists_db[state['list']]['songs'][str(indx)]['file']
            state['inlist'] = "true"
            UserConfig.loadsong(self)
            return
        if widget.get_active_id() == "load":
            Handler.LdSongPressed(self, widget)
            widget.set_active_id("name")
        elif widget.get_active_id() == "name":
            return
        elif widget.get_active_id() == "add":
            if 'true' in state['inlist']:
                return
            else:
                Handler.ListAdd(self, widget, False)
                state['inlist'] = 'true'
            return
        elif widget.get_active_id() == "search":
            gen = config['general']
            widget.set_active_id("name")
            srchfil = 'none'
            dialog = SearchDialog(window)
            response = dialog.run()
            if response == Gtk.ResponseType.CANCEL:
                UserConfig.showStatus(self, "Song not selected")
                dialog.destroy()
                return
            dialog.destroy()
            if srchfil == "none":
                return
            state['file'] = srchfil
            state['inlist'] = 'false'
            state['offset'] = "0"
            UserConfig.loadsong(self)
            UserConfig.setselectfix(self)
            UserConfig.showStatus(self, f"Loaded {state['file']}")
        else:
            widget.set_active_id("name")
            return

    def LdSongPressed(self, button):
        global config
        state = config['state']
        if state['dirty']:
            self.askToSave()
        newfile = getfilename.on_file_clicked(button)
        if newfile == "none":
            return
        state['file'] = newfile
        state['offset'] = "0"
        state['inlist'] = 'false'
        UserConfig.loadsong(self)
        UserConfig.setselectfix(self)
        UserConfig.showStatus(self, f"Loaded {state['file']}")

    def noteEntered(self, widget):
        '''This saves the top bar note to the entry
            in the songlist only'''
        global config
        global lists_db
        state = config['state']
        if state['list'] == 0:
            return
        song = lists_db[state['list']]['songs'][state['song']]
        song['notes'] = widget.get_text()
        UserConfig.save_setlist(self)

    def SaveNote(self, widget):
        ''' This saves the topbar note and the key offset
            to the song file'''
        global config
        state = config['state']
        # check for song loaded
        if (not os.path.isfile(state['file'])) or state['file'] == 'none':
            UserConfig.showStatus(self, "No song Loaded to save to")
            return
        offsetline = f"\n# transpose = {state['offset']}"
        noteline = f"\n# songnotes = {enternotes.get_text()}"
        addline = f"{offsetline}{noteline}\n\n"
        edtxst = edit_text.get_start_iter()
        edtxend = edit_text.get_end_iter()
        pageStr = edit_text.get_text(edtxst, edtxend, False)
        if pageStr.lower().find("# trans") != -1:
            pageStr = pageStr[0:pageStr.lower().find("# transpose = ")]
        pageStr = f"{pageStr}{addline}"
        edit_text.set_text(pageStr)
        Handler.editsavepress(self, widget)


    # Editor page callbacks
    def editsavepress(self, button):
        global config
        state = config['state']
        if "none" in state['file'] or state['file'] == f"{config['general']['folder']}/newsong.txt":
            self.songsaveas()
            if "none" in state['file']:
                UserConfig.showStatus(self, "Save Abandoned")
                return
        edtxst = edit_text.get_start_iter()
        edtxend = edit_text.get_end_iter()
        with open(state['file'], 'w', encoding="utf-8") as f:
            f.write(edit_text.get_text(edtxst, edtxend, False ))
        UserConfig.showStatus(self, f"Saved to {state['file']}")
        UserConfig.fillsonglist(self)
        Handler.refreshChart(self)
        state['dirty'] = False

    def editsaveas(self, button):
        self.songsaveas()

    def songsaveas(self):
        global config
        global lists_db
        state = config['state']
        state['file'] = getfilename.file_save()
        if "none" in state['file']:
            UserConfig.showStatus(self, "Save Abandoned")
            return
        edtxst = edit_text.get_start_iter()
        edtxend = edit_text.get_end_iter()
        with open(state['file'], 'w', encoding="utf-8") as f:
            f.write(edit_text.get_text(edtxst, edtxend, False ))
        UserConfig.showStatus(self, f"Saved To {state['file']}")
        UserConfig.fillsonglist(self)
        Handler.refreshChart(self)
        state['dirty'] = False

    def CreateSong(self, button):
        global config
        state = config['state']
        state['file'] = f"{config['general']['folder']}/newsong.txt"
        state['key'] = "unknown"
        state['offset'] = "0"
        state['inlist'] = "false"
        newtext = "{title: edit me}\n{subtitle: put author here}"
        newtext2 = "\n{key: unknown}\n\n{c: Verse}\n\n"
        newtext = f"{newtext}{newtext2}"
        UserConfig.setselectfix(self)
        edit_text.set_text(newtext)
        adj = webkitbox.get_hadjustment()
        adj.set_value(0.0)
        Handler.refreshChart(self)
        UserConfig.fillsonglist(self)
        state['dirty'] = True


    # set lists call backs
    def ListNewPress(self, button):
        # create a new list
        global config
        global lists_db
        state = config['state']
        dialog = NewSetDialog(self)
        response = dialog.run()
        if response == Gtk.ResponseType.OK:
            dnewname = newsetbuff.get_text()
        elif response == Gtk.ResponseType.CANCEL:
            UserConfig.showStatus(self, "New List Cancelled")
            dialog.destroy()
            return
        dialog.destroy()
        no_of_list = len(lists_db)
        if no_of_list == 0:
            list_idx = str(1)
        else:
            list_idx = str(no_of_list + 1)
        # create new set list
        state['list'] = list_idx
        lists_db[state['list']] = {
            'listname': dnewname,
            'songs': {}
        }
        setselecter.append(str(list_idx), dnewname)
        setselecter.set_active_id(str(list_idx))
        UserConfig.save_setlist(self)
        UserConfig.showStatus(self, f"Set List: {dnewname} created")

    def ListFromSelect(self):
        global config
        # ToDo Create list from selection
        # has to be added to GUI as well
        return

    def textchanged(self, widget):
        global config
        config['state']['dirty'] = True


    def RemoveList(self, widget):
        global config
        global lists_db
        state = config['state']
        dialog = OKCancelDialog(window)
        response = dialog.run()
        if response == Gtk.ResponseType.CANCEL:
            UserConfig.showStatus(self, "Remove Set List Cancelled")
            dialog.destroy()
            return
        dialog.destroy()
        no = len(lists_db)
        for x in range(int(state['list']), no):
            next_list = str(x + 1)
            next_db = lists_db[next_list].copy()
            lists_db[str(x)] = next_db
        lists_db.pop(str(no))
        state['list'] = "0"
        UserConfig.fillsonglist(self)
        UserConfig.save_setlist(self)
        UserConfig.setselectfix(self)
        UserConfig.showStatus(self, "Set List Removed")

    def RenameListPressed(self, widget):
        global config
        global lists_db
        state = config['state']
        dialog = NewSetDialog(self)
        response = dialog.run()
        if response == Gtk.ResponseType.OK:
            dnewname = newsetbuff.get_text()
        elif response == Gtk.ResponseType.CANCEL:
            UserConfig.showStatus(self, "Set List Rename Cancelled")
            dialog.destroy()
            return
        dialog.destroy()
        lists_db[state['list']]['listname'] = dnewname
        UserConfig.save_setlist(self)
        UserConfig.setselectfix(self)
        UserConfig.showStatus(self, f"Set List Renamed To: {dnewname}")

    def listsongselected(self, widget, row):
        global config
        global lists_db
        # ToDo deal with multiple songs selected
        #   - create new list
        #   - delete selected
        # selections can be shift 1st n last
        # or control clicked

        state = config['state']
        # A song was selected from the list
        if row == None:
            return
        idx = row.get_index() + 1
        state['song'] = str(idx)
        state['file'] = lists_db[state['list']]['songs'][str(idx)]['file']
        UserConfig.loadsong(self)

    def ListAdd(self, button, signalled=True):
        global config
        global lists_db
        state = config['state']
        # Add a song to the list
        placeholder = "blank"
        if state['list'] == "0":
            return
        our_db = lists_db[state['list']]['songs']
        this_idx = str(len(our_db) + 1)
        if not signalled:
            song_file = state['file']
        else:
            song_file = getfilename.on_file_clicked(button)
        if song_file == "none":
            return
        with open(song_file, encoding="utf-8") as f:
            read_data = f.read()
        if read_data.lower().find("# trans") == -1:
            os = '0'
        else:
            os1 = read_data[read_data.lower().find("# transpose = ") + 14:]
            os = os1.split("\n",1)[0].strip()
        if read_data.lower().find("# songnotes") == -1:
            songnotes = ""
        else:
            sn1 = read_data[read_data.lower().find("# songnotes = ") + 14:]
            songnotes = sn1.split("\n",1)[0].strip()
        our_db[this_idx] = {
            'file': song_file,
            'offset': os,
            'notes': songnotes
        }
        UserConfig.save_setlist(self)
        UserConfig.fillsonglist(self)

    def listSearchPress(self, button):
        global config
        global lists_db
        global srchfil
        state = config['state']
        # Add a song to the list
        placeholder = "blank"
        our_db = lists_db[state['list']]['songs']
        this_idx = str(len(our_db) + 1)
        dialog = SearchDialog(window)
        response = dialog.run()
        if response == Gtk.ResponseType.CANCEL:
            UserConfig.showStatus(self, "Song not selected")
            dialog.destroy()
            return
        dialog.destroy()
        if srchfil == "none":
            return
        with open(srchfil, encoding="utf-8") as f:
            read_data = f.read()
        if read_data.lower().find("# trans") == -1:
            os = '0'
        else:
            os1 = read_data[read_data.lower().find("# transpose = ") + 14:]
            os = os1.split("\n",1)[0].strip()
        if read_data.lower().find("# songnotes") == -1:
            songnotes = ""
        else:
            sn1 = read_data[read_data.lower().find("# songnotes = ") + 14:]
            songnotes = sn1.split("\n",1)[0].strip()
        our_db[this_idx] = {
            'file': srchfil,
            'offset': os,
            'notes': songnotes
        }
        UserConfig.save_setlist(self)
        UserConfig.fillsonglist(self)

    def ListRemoveSong(self, widget):
        global config
        global lists_db
        state = config['state']
        if state['list'] == '0':
            print("no list selected")
            return
        if state['song'] == '0':
            print("no selected song")
            return
        our_db = lists_db[state['list']]['songs']
        no = len(our_db)
        if no == 1:
            our_db.pop(str(no))
            state['song'] = '0'
            state['file'] = "none"
        else:
            for x in range(int(state['song']), no):
                next_song = str(x + 1)
                next_db = our_db[next_song].copy()
                our_db[str(x)] = next_db
            our_db.pop(str(no))
            if int(state['song']) == no:
                state['song'] = str(no - 1)
            state['file'] = our_db[state['song']]['file']
        UserConfig.fillsonglist(self)
        UserConfig.save_setlist(self)
        UserConfig.loadsong(self)

    def listSongDown(self, widget):
        global config
        global lists_db
        state = config['state']
        our_db = lists_db[state['list']]['songs']
        csng = int(state['song'])
        clen = len(our_db)
        if csng < 1 or (csng > (clen - 1)):
            print("out of range for operation")
            return
        this_db = our_db[state['song']].copy()
        next_song = str(int(state['song']) + 1)
        next_db = our_db[next_song].copy()
        our_db[next_song] = this_db
        our_db[state['song']] = next_db
        state['song'] = next_song
        UserConfig.fillsonglist(self)
        UserConfig.save_setlist(self)

    def listSongUp(self, widget):
        global config
        global lists_db
        state = config['state']
        our_db = lists_db[state['list']]['songs']
        csng = int(state['song'])
        clen = len(our_db)
        if csng < 2 or (csng > (clen)):
            print("out of range for operation")
            return
        this_db = our_db[state['song']].copy()
        next_song = str(int(state['song']) - 1)
        next_db = our_db[next_song].copy()
        our_db[next_song] = this_db
        our_db[state['song']] = next_db
        state['song'] = next_song
        UserConfig.fillsonglist(self)
        UserConfig.save_setlist(self)


    # Utilities
    def pdfSaveSong(self, widget):
        global config
        pdf = config['pdf']
        zm = float(pdf['zoom'])/100
        file_name = os.path.basename(config['state']['file']).split('.')[0]
        newName = f"{pdf['folder']}/{file_name}.pdf"
        edtxst = edit_text.get_start_iter()
        edtxend = edit_text.get_end_iter()
        pageStr = edit_text.get_text(edtxst, edtxend, False)
        ofst = config['state']['offset']
        boxht = int(pdf['height'])
        cols = pdf['columns']
        newhtml = ChordPro.toHtml(self, pageStr, boxht, ofst, cols, zm)
        urlpath = f"file://{config['state']['config_path']}/pdf/"
        HTML(string=newhtml, base_url=urlpath).write_pdf(newName)

    def pdfSaveListFiles(self, widget):
        global config
        global lists_db
        pdf = config['pdf']
        zm = float(pdf['zoom'])/100
        if config['state']['list'] == 0:
            UserConfig.showStatus(self, "No set list loaded to convert")
            return
        ourlist = lists_db[config['state']['list']]['songs']
        for x in ourlist:
            file = ourlist[x]['file']
            ofst = ourlist[x]['offset']
            file_name = os.path.basename(file).split('.')[0]
            fullname = f"{pdf['folder']}/{file_name}.pdf"
            boxht = int(pdf['height'])
            if not os.path.isfile(file):
                read_data = "{t: Missing File!}\n{st: Music Pager}\n"
                read_data = f"{read_data}could not find\nFile: {file}"
                UserConfig.showStatus(self, f"pdf missing {file}")
            else:
                with open(file, encoding="utf-8") as f:
                    read_data = f.read()
            cols = pdf['columns']
            newhtml = ChordPro.toHtml(self, read_data, boxht, ofst, cols, zm)
            urlpath = f"file://{config['state']['config_path']}/pdf/"
            HTML(string=newhtml, base_url=urlpath).write_pdf(fullname)


    def pdfSaveListBook(self, widget):
        global config
        global lists_db
        pdf = config['pdf']
        zm = float(pdf['zoom'])/100
        if config['state']['list'] == 0:
            UserConfig.showStatus(self, "No set list loaded to convert")
            return
        ourlist = lists_db[config['state']['list']]['songs']
        listname = lists_db[config['state']['list']]['listname']
        bookfile = f"{pdf['folder']}/{listname}.pdf"
        doclist = []
        for x in ourlist:
            file = ourlist[x]['file']
            ofst = ourlist[x]['offset']
            file_name = os.path.basename(file).split('.')[0]
            boxht = int(pdf['height'])
            if not os.path.isfile(file):
                read_data = "{t: Missing File!}\n{st: Music Pager}\n"
                read_data = f"{read_data}could not find\nFile: {file}"
                UserConfig.showStatus(self, f"pdf missing {file}")
            else:
                with open(file, encoding="utf-8") as f:
                    read_data = f.read()
            cols = pdf['columns']
            newhtml = ChordPro.toHtml(self, read_data, boxht, ofst, cols, zm)
            urlpath = f"file://{config['state']['config_path']}/pdf/"
            doclist.append(HTML(string=newhtml, base_url=urlpath).render())
        all_pages = [p for doc in doclist for p in doc.pages]
        doclist[0].copy(all_pages).write_pdf(bookfile)

    def pdfOpenReader(self, widget):
        global config
        pdf = config['pdf']
        zm = float(pdf['zoom'])/100
        file_name = os.path.basename(config['state']['file']).split('.')[0]
        template = f"{pdf['folder']}/{file_name}.pdf"
        edtxst = edit_text.get_start_iter()
        edtxend = edit_text.get_end_iter()
        pageStr = edit_text.get_text(edtxst, edtxend, False)
        longest = ChordPro.getlongline(self, pageStr)
        ofst = config['state']['offset']
        #boxht = 1056 # Page height try X1228X
        boxht = int(pdf['height'])
        cols = pdf['columns']
        newhtml = ChordPro.toHtml(self, pageStr, boxht, ofst, cols, zm)
        urlpath = f"file://{config['state']['config_path']}/pdf/"
        with tempfile.NamedTemporaryFile(delete_on_close=False) as fp:
            fp.write(HTML(string=newhtml, base_url=urlpath).write_pdf(None))
            fp.close()
            cmd = f"xdg-open {fp.name}"
            os.popen(cmd)
            time.sleep(1)

    def PDFfolderset(self, widget):
        global config
        if config['pdf']['folder'] == widget.get_current_folder():
            return
        config['pdf']['folder'] = widget.get_current_folder()
        UserConfig.Save(self)

    def pdfcolumns(self, widget):
        global config
        if config['pdf']['columns'] == widget.get_active_id():
            return
        config['pdf']['columns'] = widget.get_active_id()
        UserConfig.Save(self)

    def pdflyricsSet(self, widget):
        global config
        if config['pdf']['lyrics'] == str(widget.get_active()):
            return
        config['pdf']['lyrics'] = str(widget.get_active())
        UserConfig.Save(self)

    def pdfZoomSet(self, widget):
        global config
        if config['pdf']['zoom'] == str(widget.get_value()):
            return
        config['pdf']['zoom'] = str(int(widget.get_value()))
        UserConfig.save_webcss(self)
        UserConfig.Save(self)

    def pdfColourSet(self, widget):
        global config
        if config['pdf']['colour'] == str(widget.get_active()):
            return
        config['pdf']['colour'] = str(widget.get_active())
        UserConfig.save_webcss(self)
        UserConfig.Save(self)


    # Settings
    def stylechanged(self, widget):
        global config
        if not widget.get_sensitive():
            return
        webdb = config['webkit']
        webdb['zoom'] = str(stylezoom.get_value_as_int())
        webdb['title']['size'] = str(styletitlesz.get_value_as_int())
        webdb['subtitle']['size'] = str(stylesubtsz.get_value_as_int())
        webdb['chords']['size'] = str(stylechordsz.get_value_as_int())
        webdb['lyrics']['size'] = str(stylelyricsz.get_value_as_int())
        webdb['comment']['size'] = str(stylecommentsz.get_value_as_int())
        webdb['title']['color'] = styletitleclr.get_active_id()
        webdb['subtitle']['color'] = stylesubtclr.get_active_id()
        webdb['chords']['color'] = stylechordclr.get_active_id()
        webdb['lyrics']['color'] = stylelyricclr.get_active_id()
        webdb['comment']['color'] = stylecommentclr.get_active_id()
        config['general']['pagesize'] = str(int(450 * int(webdb['zoom']) / 100))
        UserConfig.Save(self)
        UserConfig.save_webcss(self)
        self.refreshChart()

    def hotKeySet(self, widget):
        if widget == getpn:
            hktype = 'pagenext'
        elif widget == getpb:
            hktype = 'pageback'
        elif widget == getsn:
            hktype = 'songnext'
        elif widget == getsb:
            hktype = 'songback'
        elif widget == getku:
            hktype = 'keyup'
        elif widget == getkd:
            hktype = 'keydown'
        newlb = Handler.hotkeydetect(self, hktype)
        widget.set_label(newlb)
        return

    def hotkeydetect(self, kind):
        global config
        hot = config['hotkeys']
        dialog = GetKeyDialog(self)
        response = dialog.run()
        if response == Gtk.ResponseType.OK:
            key = Gdk.keyval_name(dialog.ourkey)
        elif response == Gtk.ResponseType.DELETE_EVENT:
            key = "#"
        elif response == Gtk.ResponseType.CANCEL:
            UserConfig.showStatus(self, "Set hotkey Cancelled")
            dialog.destroy()
            return
        hot[kind] = key
        dialog.destroy()
        UserConfig.Save(self)
        UserConfig.sethotkeys(self)
        return key

    def midiKeySet(self, widget):
        if widget == midipn:
            mktype = 'pagenext'
        elif widget == midipb:
            mktype = 'pageback'
        elif widget == midisn:
            mktype = 'songnext'
        elif widget == midisb:
            mktype = 'songback'
        elif widget == midiku:
            mktype = 'keyup'
        elif widget == midikd:
            mktype = 'keydown'
        newlb = Handler.midikeydetect(self, mktype)
        widget.set_label(newlb)
        return

    def midikeydetect(self, kind):
        global config
        global midi_dial
        midi = config['midi']
        if midi['device'] == 'none':
            UserConfig.showStatus(self, "No device open")
            return
        dialog = GetMIDIDialog(self)
        midi_dial = dialog
        response = dialog.run()
        if response == Gtk.ResponseType.OK:
            event = midi['choice']
        elif response == Gtk.ResponseType.DELETE_EVENT:
            event = "#"
        elif response == Gtk.ResponseType.CANCEL:
            UserConfig.showStatus(self, "Set midi Cancelled")
            dialog.destroy()
            return midi[kind]
        midi[kind] = event
        dialog.destroy()
        UserConfig.Save(self)
        return event

    def MidiDevChanged(self, widget):
        global config
        if not widget.get_sensitive():
            return
        newdev = widget.get_active_text()
        if newdev == config['midi']['device']:
            return
        config['midi']['device'] = newdev
        UserConfig.midiopen(self)

    def MidiBackEnd(self, widget):
        '''Change the MIDI backend between ALSA and Jack'''
        global config
        config['midi']['backend'] = widget.get_active_id()
        UserConfig.midireset(self)
        UserConfig.mididevicelist(self)
        UserConfig.midiopen(self)

    def midi_cmds(self):
        '''This is a timer callback used to decouple rtmidi
            from the commands it runs to add stabilty and
            keep from crashing'''
        global config
        db = config['midi']
        event = db['cmd']
        if not 'none' in event:
            if str(event) == db['keyup']:
                chrtku.emit("clicked")
            elif str(event) == db['keydown']:
                chrtkd.emit("clicked")
            elif str(event) == db['pagenext']:
                chrtpn.emit("pressed")
            elif str(event) == db['pageback']:
                chrtpb.emit("pressed")
            elif str(event) == db['songnext']:
                chrtsn.emit("pressed")
            elif str(event) == db['songback']:
                chrtsb.emit("pressed")
            db['cmd'] = 'none'
        return True

    def autosongchange(self, widget):
        global config
        if not widget.get_sensitive():
            return
        config['general']['autosong'] = str(widget.get_active())
        UserConfig.Save(self)

    def BaseFolderSet(self, widget):
        global config
        new_fldr = widget.get_current_folder()
        config['general']['folder'] = new_fldr
        UserConfig.Save(self)
        UserConfig.saveSongs(self)

    def subfolderdepth(self, widget):
        global config
        depth = widget.get_value_as_int()
        if depth < 0:
            depth = 0
            widget.set_value(depth)
        elif depth > 2:
            depth = 2
            widget.set_value(depth)
        config['general']['folderdepth'] = depth
        UserConfig.Save(self)
        UserConfig.saveSongs(self)

    def refreshSongs(self, widget):
        UserConfig.saveSongs(self)


# this code initializes stuff
# I expect the right way would be to include this in a class
global appname
global config
global settingvisit
settingvisit = False

appname = "musicpager"
appversion = "version: 1.2.0"

# set up our glade file
builder = Gtk.Builder()
builder.add_from_file(f"{install_path}/share/{appname}/{appname}.glade")
builder.connect_signals(Handler())
# bring objects from glade file into our space and set them up

#main window
window = builder.get_object("window_1")
nbook = builder.get_object("Nbook_id")
mainkeysign = builder.get_object("mainkeysign")
enternotes = builder.get_object("enterNotes")
mainsongsel = builder.get_object("MainSongSelect")
maininfo = builder.get_object("MainInfo")
setselecter = builder.get_object("setSelecter") #set select dropdown
accelgrp = Gtk.AccelGroup()
window.set_default_icon_name('musicpager')
window.set_title(f"Music Pager - {appversion}")
window.add_accel_group(accelgrp)

#editor
edit_text = builder.get_object("editor_buffer")
edtexwin = builder.get_object("edTexWin")

# webkit display
# scroller for web display so we can page
webkitbox = builder.get_object("WebKitholder")
# big enough box to make webkit2 not self scroll.
webbigBox = builder.get_object("bigBox")
# box (window?) to attach accelorators to
pagebox = builder.get_object("pagebox")
#control buttons...
chrtpb = builder.get_object("chrtPBckBut")
chrtsb = builder.get_object("chrtSBckBut")
chrtku = builder.get_object("chrtKUpBut")
rdmanbut = builder.get_object("RdManButton")
chrtkd = builder.get_object("chrtKDnBut")
chrtsn = builder.get_object("chrtSNxtBut")
chrtpn = builder.get_object("chrtPNxtBut")

#setlist
songlist = builder.get_object("songlist")
newsetbuff = builder.get_object("NewSetBuff") # Buffer for dialog

# utilities
pdffoldersel = builder.get_object("pdfFolderSel")
pdfcoldrop = builder.get_object("pdfColDrop")
pdflyricsonly = builder.get_object("pdflyricsonly")
pdfzoomspin = builder.get_object("PdfZoomSpin")
pdfcolourch = builder.get_object("pdfColourCh")

#settings
stylezoom = builder.get_object("chartzoom")
styletitlesz = builder.get_object("styletitlesz")
stylesubtsz = builder.get_object("stylesubtsz")
stylechordsz = builder.get_object("stylechordsz")
stylelyricsz = builder.get_object("stylelyricsz")
stylecommentsz = builder.get_object("stylecommentsz")
styletitleclr = builder.get_object("styletitleclr")
stylesubtclr = builder.get_object("stylesubtclr")
stylechordclr = builder.get_object("stylechordclr")
stylelyricclr = builder.get_object("stylelyricclr")
stylecommentclr = builder.get_object("stylecommentclr")
ChartStyle = builder.get_object("ChartStyle")
basefoldersel = builder.get_object("BaseFolderSel")
folderdepth = builder.get_object("FolderDepth")
autosong = builder.get_object("autoSong")
# accel settings
getpn = builder.get_object("GetPN")
getpb = builder.get_object("GetPB")
getsn = builder.get_object("GetSN")
getsb = builder.get_object("GetSB")
getku = builder.get_object("GetKU")
getkd = builder.get_object("GetKD")
midipn = builder.get_object("midiPN")
midipb = builder.get_object("midiPB")
midisn = builder.get_object("midiSN")
midisb = builder.get_object("midiSB")
midiku = builder.get_object("midiKU")
midikd = builder.get_object("midiKD")
mididevice = builder.get_object("midiDevice")
midiapidrop = builder.get_object("midiapidrop")
cnfctl = UserConfig()
config['version'] = appversion
UserConfig.Save(window)
def gtk_style():
    css = b"""
* {
    transition-property: color, background-color, border-color, background-image, padding, border-width;
    transition-duration: 1s;
    font-family: Cantarell;
    font-size: 22px;
}
window {
    background-color: #999999;
}
textview.view {
    font-family: Cantarell;
    font-size: 32px;
}
textview text {
    background-color: #ffffff;
    color: #000000;
}

        """
    style_provider = Gtk.CssProvider()
    style_provider.load_from_data(css)

    Gtk.StyleContext.add_provider_for_screen(
        Gdk.Screen.get_default(),
        style_provider,
        Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION
    )

gtk_style()
# need to set default setup values
window_x = int(config['state']['main_x'])
window_y = int(config['state']['main_y'])
# need to read in config file if there is one
# size should be set in settings so we can save it for next time.
window.set_default_size(window_x, window_y)
# glade doesn't have webview so add it here
wview = WebKit2.WebView()
# pack it in a big box so we can scroll
webbigBox.pack_start(wview, True, True, 0)
# pointer to show a file chooser dialog
getfilename = FileChooserWindow()

bus = dbus.SessionBus()
saver = bus.get_object('org.freedesktop.ScreenSaver', '/ScreenSaver')
saver_interface = dbus.Interface(saver, dbus_interface='org.freedesktop.ScreenSaver')

# now we can inhibit the screensaver
# should this only be active when pager box is visible?
# (might save battery)
blank=saver_interface.Inhibit(appname, "So I can read the music")

# put our window on the screen
window.show_all()
timeout_id = GLib.timeout_add(250, Handler.midi_cmds, None)

#start main loop
Gtk.main()

